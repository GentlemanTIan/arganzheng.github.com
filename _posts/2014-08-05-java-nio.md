---
title: Java NIO
layout: post
---


WHAT is Java NIO
----------------

虽然说Java NIO的真正含义是Non-Blocking IO。但是实际上它的字面意义是Java New IO，在Java 1.4的时候引入，用于区分原来老的IO方式。整个新的IO API是为服务器设计的，只与服务器相关。


WHY NIO
-------

### 1. 网络IO往往是性能瓶颈

与CPU和内存相比，甚至与磁盘相比，网络都很慢。CPU与主存之间的传输速度大概是6GB每秒。与之相比，磁盘的传输速度要慢的多，但是也能够达到150MB每秒。但是，当今最快的局域网的理论速度是每秒120MB，但是大多数LAN只支持这个速度的十分之一到百分之一。而通过公用的Internet传输的速度一般至少要比LAN的速度低一个数量级。随着时间的的推移，CPU、内存、磁盘和网络都会随着时间而加速。但是在可预见的将来，CPU和磁盘或许仍然会比网络速度快几个数量级。在这种情况下，你绝对不希望让异常快速的CPU等待相对缓慢的网络。

### 2. 多进程和多线程方案

对于CPU速度远高于网络IO的情况，传统的Java解决方案是缓冲和多线程。多线程可以同时为几个不同的连接生成数据是，并且将数据存储在缓冲区中，知道网络真正准备好再发送。但是，多线程方案也有下面这些缺点：

1. 内存开销：每个线程需要大概1M的内存
2. 线程调度以及上下文切换开销
3. 并发控制以及同步机制：复杂而且容易出错


NIO的四个核心概念
-----------------

NIO的核心抽象是如下四个概念[Package java.nio](http://docs.oracle.com/javase/7/docs/api/java/nio/package-summary.html)：

1. Buffers, which are containers for data;
2. Charsets and their associated decoders and encoders, which translate between bytes and Unicode characters;
3. Channels of various types, which represent connections to entities capable of performing I/O operations; Its job is to abstract files and sockets. Channels are analogous to "file descriptors" found in Unix-like operating systems.
4. Selectors and selection keys, which together with selectable channels define a multiplexed, non-blocking 
I/O facility.

![Selector](http://image.slidesharecdn.com/javanio-100701052238-phpapp02/95/slide-17-728.jpg?1277979880)


### 1. Buffers(缓冲区)

在使用Blocking IO的时候，一般都会建议使用缓冲区。与提供足够大缓冲区相比，几乎没有那种方法能够对网络程序的性能产生更大的影响。但是，对于新的IO模型，你将没有选择，所有的IO都要被缓冲。事实上，缓冲区已经成为API的基本部分。在新的IO模型中，不再向输出流写入数据或者输入流读取数据，而是要从缓冲区中读写数据。

除了boolean之外，每种Java简单类型都有特定的Buffer子类：

* ByteBuffer
* CharBuffer
* ShortBuffer
* IntBuffer
* LongBuffer
* FloatBuffer
* DoubleBuffer

但是基本上网络程序只会使用ByteBuffer。

每个缓冲区都记录了信息的四个关键部分，并且提供方法让程序获取和设置这些值：

1. 位置(position)
2. 容量(capacity)：创建之后不能改变。
3. 限度(limit)
4. 标记(mark)

position marks the reading position, and limit marks how many bytes, chars etc. were written into the buffer - the limit of how many bytes, chars etc. that can be read.

与读取InputStream不同，读取缓冲区实际上不会以任何方式改变缓冲区中的数据，只可能向前或者向后改变位置，从而实现从缓冲区中某个位置开始读取。

**分配Buffer**

* ByteBuffer buf = ByteBuffer.allocate(100);
* ByteBuffer buf = ByteBuffer.allocateDirect(100);

**使用现有数组构造Buffer**

* static ByteBuffer wrap(byte[] array)
* static ByteBuffer wrap(char[] array)
* etc.

可以把Buffers的方法按照 “操作游标” 和 “操作缓冲区” 这两个维度进行划分。

1. 只操作游标的方法 
2. 只操作缓冲区的方法
	* Absolute (bulk) get/put method
3. 既操作了缓冲区，也操作了游标的方法
	* Relative (bulk) get/put method
	* compact

### 2. Channel(通道)

通道将缓冲区的数据移入或者移出到各种IO源，如文件、Socket等。

Channel与Stream之间的关键区别有如下几个方面：

1. bi-directional. You can both read and write to a Channels. Streams are typically one-way (read or write).
2. non-blocking with Selectors. Channels can be read and written asynchronously.
3. block-oriented with Buffers. A stream-oriented I/O system deals with data one byte at a time. A block-oriented I/O system deals with data in blocks. Channels always read to, or write from, a Buffer.

从这个角度来看，Buffer更像是Stream的概念，Channel更像是文件描述符的概念。

最重要的四种通道实现类如下：

* FileChannel: The FileChannel reads data from and to files.
* DatagramChannel: The DatagramChannel can read and write data over the network via UDP.
* SocketChannel: The SocketChannel can read and write data over the network via TCP.
* ServerSocketChannel: The ServerSocketChannel allows you to listen for incoming TCP connections, like a web server does. For each incoming connection a SocketChannel is created.

As you can see, these channels cover UDP + TCP network IO, and file IO.


**TIPS** Java NIO Scatter / Gather

Scatter/gather I/O is a method of reading and writing that uses multiple buffers(array of buffers), rather than a single buffer, to hold data.

Channels can optionally implement two new interfaces: ScatteringByteChannel and GatheringByteChannel:

* long read( ByteBuffer[] dsts );
* long read( ByteBuffer[] dsts, int offset, int length );
* long write( ByteBuffer[] srcs );
* long write( ByteBuffer[] srcs, int offset, int length );

#### 1. FileChannel

A Java NIO FileChannel is a channel that is connected to a file. Using a file channel you can read data from a file, and write data to a file.

**NOTE** A FileChannel cannot be set into non-blocking mode. It always runs in blocking mode.

Before you can use a FileChannel you must open it. You cannot open a FileChannel directly. You need to obtain a FileChannel via an InputStream, OutputStream, or a RandomAccessFile.

	RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");
	FileChannel inChannel = aFile.getChannel();

#### 2. SocketChannel

A Java NIO SocketChannel is a channel that is connected to a TCP network socket. There are two ways a SocketChannel can be created:

1. You open a SocketChannel and connect to a server somewhere on the internet.
	
		SocketChannel socketChannel = SocketChannel.open();
		socketChannel.connect(new InetSocketAddress("http://jenkov.com", 80));

2. A SocketChannel can be created when an incoming connection arrives at a ServerSocketChannel.
		
		SocketChannel socketChannel = serverSocketChannel.accept();

**TIPS** Non-blocking Mode

You can set a SocketChannel into non-blocking mode. When you do so, you can call connect(), read() and write() in asynchronous mode.

	socketChannel.configureBlocking(false);

#### 3. ServerSocketChannel

A Java NIO ServerSocketChannel is a channel that can listen for incoming TCP connections, just like a ServerSocket in standard Java Networking. 

You open a ServerSocketChannel by calling the ServerSocketChannel.open() method. Here is how that looks:

	ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

例子：

	serverSocketChannel.socket().bind(new InetSocketAddress(9999));

	while(true){
	    SocketChannel socketChannel = serverSocketChannel.accept();
	    //do something with socketChannel...
	}

**TIPS** Non-blocking Mode

A ServerSocketChannel can be set into non-blocking mode. In non-blocking mode the accept() method returns immediately, and may thus return null, if no incoming connection had arrived. Therefore you will have to check if the returned SocketChannel is null. Here is an example:

	ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

	serverSocketChannel.socket().bind(new InetSocketAddress(9999));
	serverSocketChannel.configureBlocking(false);

	while(true){
	    SocketChannel socketChannel = serverSocketChannel.accept();

	    if(socketChannel != null){
	        //do something with socketChannel...
		}
	}

#### 4. DatagramChannel

A Java NIO DatagramChannel is a channel that can send and receive UDP packets. Since UDP is a connection-less network protocol, you cannot just by default read and write to a DatagramChannel like you do from other channels. Instead you send and receive packets of data.

	DatagramChannel channel = DatagramChannel.open();
	channel.socket().bind(new InetSocketAddress(9999));

**TIPS**

Channel的区别一般在于打开和获取的方式不同，一旦获得一个Channel，那么接下来的读写过程基本都是一样的（要注意区分Non-blocking Mode）。

### 3. Selector(选择器)

一般的使用步骤

1. Creating a Selector
2. Registering Channels with the Selector
3. Selecting Channels via a Selector

#### 1. Creating a Selector

You create a Selector by calling the Selector.open() method, like this:

	Selector selector = Selector.open();

#### 2. Registering Channels with the Selector

	channel.configureBlocking(false);
	SelectionKey key = channel.register(selector, SelectionKey.OP_READ);

**说明**

1. The Channel must be in non-blocking mode to be used with a Selector. This means that you cannot use FileChannel's with a Selector since FileChannel's cannot be switched into non-blocking mode. Socket channels will work fine though.
2. Notice the second parameter of the register() method. This is an "interest set", meaning what events you are interested in listening for in the Channel, via the Selector. There are four different events you can listen for:

* Connect
* Accept
* Read
* Write

对应SelectionKey的四个常量：

* SelectionKey.OP_CONNECT
* SelectionKey.OP_ACCEPT
* SelectionKey.OP_READ
* SelectionKey.OP_WRITE

如果对多个事件感兴趣，可以使用Or操作符：
	
	int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;    

#### SelectionKey

将一个通道注册到Selector之后，返回一个SelectionKey对象。这个SelectionKey对象包含如下几个重要的信息：

* The interest set: int interestSet = selectionKey.interestOps();
* The ready set: int readySet = selectionKey.readyOps();
* The Channel: selectionKey.channel();
* The Selector: selectionKey.selector(); 
* An attached object (可选，类似于上下文的概念): selectionKey.attachment();

#### 3. Selecting Channels via a Selector

将Channel注册到Selector之后，可以调用select方法对这些通道进行监听。

* int select() - blocks 
* int select(long timeout) - blocks with timeout
* int selectNow() - non-block. return 0 immediately if none is ready.

int返回值表示有多少个channel是ready的。

你可以通过Selector的selectedKeys得到ready的channels:

	Set<SelectionKey> selectedKeys = selector.selectedKeys();    

然后你可以遍历这个Selected key集合得到准备好的Channels:

	Set<SelectionKey> selectedKeys = selector.selectedKeys();

	Iterator<SelectionKey> keyIterator = selectedKeys.iterator();

	while(keyIterator.hasNext()) {
	    
	    SelectionKey key = keyIterator.next();

	    if(key.isAcceptable()) {
	        // a connection was accepted by a ServerSocketChannel.
	        // ServerSocketChannel ssc = (ServerSocketChannel)key.channel();
			// SocketChannel sc = ssc.accept();
	    } else if (key.isConnectable()) {
	        // a connection was established with a remote server.
	        // ServerSocketChannel ssc = (ServerSocketChannel)key.channel();
			// SocketChannel sc = ssc.accept();
	    } else if (key.isReadable()) {
	        // a channel is ready for reading
	        // SocketChannel sc = (SocketChannel)key.channel();
	    } else if (key.isWritable()) {
	        // a channel is ready for writing
	        // SocketChannel sc = (SocketChannel)key.channel();
	    }

	    keyIterator.remove();
	}

**NOTE** 

1. 一旦处理完selectionKey，记得将它从selectedKeySet中移除。否则下次select仍然会出现。
2. 通过SelectionKey.channel()返回的Ready Channel应该根据情况，转换为相应的类型。比如ServerSocketChannel或者SocketChannel，等等。


Memory mapping
--------------

Example: map a FileChannel (all or a portion of it) into memory. 

For this we use the FileChannel.map() method. The following line of code maps the first 1024
bytes of a file into memory:

	MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE, 0, 1024 );

The map() method returns a MappedByteBuffer, which is a subclass of ByteBuffer. Thus, you can use the newly-mapped buffer as you would any other ByteBuffer, and the operating system will take care of doing the mapping for you, on demand.


Java NIO.2
----------

Java 1.7有引入了NIO 2，主要是引入了AIO。至此，Java总算是覆盖了底层操作系统所有的IO模型了。


参考文章
--------

1. [The Rox Java NIO Tutorial](http://rox-xmlrpc.sourceforge.net/niotut/)
2. [Java NIO vs. IO](Java NIO vs. IO)
3. [Java NIO Tutorial](http://tutorials.jenkov.com/java-nio/index.html)
4. [Getting started with NIO](http://cs.brown.edu/courses/cs161/papers/j-nio-ltr.pdf)
